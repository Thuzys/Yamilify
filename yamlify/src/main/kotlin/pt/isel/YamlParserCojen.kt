package pt.isel

import org.cojen.maker.ClassMaker
import org.cojen.maker.MethodMaker
import org.cojen.maker.Variable
import java.io.FileOutputStream
import java.lang.reflect.Parameter
import java.lang.reflect.ParameterizedType
import kotlin.reflect.KClass
import kotlin.reflect.KProperty1
import kotlin.reflect.full.findAnnotation
import kotlin.reflect.full.memberProperties

/**
 * index used as default getter value in the map (the first index)
 * if the map is empty, the code will fail during the newInstance method
 */
private const val DEFAULT_GETTER_VALUE = "-0"

/**
 * A YamlParser that uses Cojen Maker to generate a parser.
 */
open class YamlParserCojen<T : Any>(
    private val type: KClass<T>,
    private val nrOfInitArgs: Int)
    : AbstractYamlParser<T>(type) {

    private val parameters: Array<out Parameter> = if (type in primitiveType) {
        emptyArray()
    } else {
        type.java.constructors.first { it.parameters.size == nrOfInitArgs }.parameters
    }

    companion object {

        private val mPMap = mutableMapOf<KClass<*>, Collection<KProperty1<*, *>>>()

        private val yamlParsers: MutableMap<String, YamlParserCojen<*>> = mutableMapOf()

        @Suppress("UNCHECKED_CAST")
        fun <T: Any> getProperties(type: KClass<T>): Collection<KProperty1<T, *>> {
            return mPMap.getOrPut(type) {
                type.memberProperties
            } as Collection<KProperty1<T, *>>
        }


        private fun parserName(type: KClass<*>, nrOfInitArgs: Int): String {
            return "YamlParser${type.simpleName}$nrOfInitArgs"
        }
        /*
         * Creates a YamlParser for the given type using Cojen Maker if it does not already exist.
         * Keep it in an internal cache.
         */
        @Suppress("UNCHECKED_CAST")
        fun <T : Any> yamlParser(
            type: KClass<T>,
            nrOfInitArgs: Int = type.constructors.first().parameters.size,
        ): AbstractYamlParser<T> {
            return yamlParsers.getOrPut(parserName(type, nrOfInitArgs)) {
                YamlParserCojen(type, nrOfInitArgs)
                    .buildYamlParser()
                    .finish()
                    .getConstructor(KClass::class.java, Int::class.java)
                    .newInstance(type, nrOfInitArgs) as YamlParserCojen<*>
            } as YamlParserCojen<T>
        }

        fun <T: Any> yamlParser(type: Class<T>, nrOfInitArgs: Int) : AbstractYamlParser<T> =
            yamlParser(type.kotlin, nrOfInitArgs)

        fun <T: Any> yamlParser(type: Class<T>) : AbstractYamlParser<T> =
            yamlParser(type.kotlin)

        fun <T: Any>testBuildMaker(type: KClass<T>, nrOfInitArgs: Int) {
            val cm = YamlParserCojen(type, nrOfInitArgs).buildYamlParser()
            cm.finishTo(FileOutputStream("YamlParserCojenDummy.class"))
        }
    }
    /**
     * Used to get a parser for other Type using the same parsing approach.
     */
    override fun <T : Any> yamlParser(type: KClass<T>) = YamlParserCojen.yamlParser(type)

    /**
     * Do not change this method in YamlParserCojen.
     */
    override fun newInstance(args: Map<String, Any>): T {
        throw UnsupportedOperationException(
            "This method is overridden in a subclass dynamically generated by buildYamlParser() function!"
        )
    }

    /**
     * Builds the YamlParser using Cojen Maker.
     * representation of the class in java :
     *
     *
     *      public class YamlParserCojenDummy implements YamlParserCojen<T> {
     *          private final Ktype<T> type;
     *          private final int nrOfInitArgs;
     *
     *          public YamlParserCojen(KClass<T> type, int nrOfInitArgs) {
     *              super (type, nrOfInitArgs);
     *              this.type = type;
     *              this.nrOfInitArgs = nrOfInitArgs;
     *          }
     *          public T newInstance(Map<String, Any> args) {
     *              /*
     *                  take the first constructor with the same
     *                  number of arguments as nrOfInitArgs
     *                  and create a new instance of the type
     *                  with the arguments in the map
     *              */
     *          }
     *
     *          public T parseObject(Reader yaml) {...}
     *
     *          public List<T> parseList(Reader yaml) {...}
     *
     *          public YamlParser<T> yamlParser(KClass<T> type) {...}
     *      }
     */
    private fun buildYamlParser() : ClassMaker {
        // create the ClassMaker
        val cm = ClassMaker
            .begin()
            .public_()
            .extend(YamlParserCojen::class.java)
        // create the type field
        val fieldType = cm
            .addField(KClass::class.java, "type")
            .private_()
            .final_()
        // create the nrOfInitArgs field
        val fieldNrOfInitArgs = cm
            .addField(Int::class.java, "nrOfInitArgs")
            .private_()
            .final_()
        // add the constructor to the class
        val init = cm
            .addConstructor(KClass::class.java, Int::class.java)
            .public_()
        init
            .field(fieldType.name())
            .set(init.param(0))
        init
            .field(fieldNrOfInitArgs.name())
            .set(init.param(1))
        // call the superclass constructor and set the parameters
        init
            .invokeSuperConstructor(init.param(0), init.param(1))
        // add the newInstance method to the class
        val methodNewInstance = cm
            .addMethod(Any::class.java, "newInstance", Map::class.java)
            .public_()
            .override()
        buildNewInstanceMethod(methodNewInstance)
        return cm
    }

    private fun buildNewInstanceMethod(method: MethodMaker) {
        if (type in primitiveType) {
            method.return_(method.param(0).invoke("get", ""))
            return
        }
        val yamlConvert = hashMapOf<String, YamlConvert>()
        val yamlArg = hashMapOf<String, String>()
        getProperties(type)
            .filter { property -> parameters.any { param -> param.name == property.name } }
            .forEach { property ->
                val scrName = property.findAnnotation<YamlArg>()?.scrName
                val cVert: YamlConvert? = property.findAnnotation<YamlConvert>()

                if (scrName != null) {
                    yamlArg[property.name] = scrName
                }

                cVert?.let { cV ->
                    yamlConvert[property.name] = cV
                }
            }
        val args = method.param(0)
        val argsList = parameters.map { param ->
            val value = args
                .invoke("get", param.name)
            value.ifEq(null) {
                value.set(
                    args.invoke("get", yamlArg[param.name])
                )
            }
            val convert = yamlConvert[param.name]
            if (convert != null) {
                method.new_(convert.converter.java)
                    .invoke("strConverter", value.cast(String::class.java))
            } else {
                typeOf(method, value, param)
            }
        }.toTypedArray()
        val retObj = method.new_(type.java, *argsList)
        method.return_(retObj)
    }

    private fun typeOf(
        method: MethodMaker,
        v: Variable,
        param: Parameter,
    ): Variable {
        return when(val jClass = param.type) {
            Int::class.java -> typeParser(method, v, Int::class.java, "parseInt")
            Char::class.java -> v.invoke("charAt", 0)
            Boolean::class.java -> typeParser(method, v, Boolean::class.java, "parseBoolean")
            Long::class.java -> typeParser(method, v, Long::class.java, "parseLong")
            Short::class.java -> typeParser(method, v, Short::class.java, "parseShort")
            Byte::class.java -> typeParser(method, v, Byte::class.java, "parseByte")
            Double::class.java -> typeParser(method, v, Double::class.java, "parseDouble")
            Float::class.java -> typeParser(method, v, Float::class.java, "parseFloat")
            String::class.java -> v.cast(String::class.java)
            else -> {
                val map = v.cast(Map::class.java)
                val companion =
                    method
                        .`var`(YamlParserCojen::class.java)
                        .field("Companion")
                if (jClass == List::class.java) {
                    val type = param.parameterizedType as ParameterizedType
                    val typeClass = type.actualTypeArguments[0] as Class<*>
                    if (typeClass.kotlin !in primitiveType) {
                        companion
                            .invoke(
                                "yamlParser",
                                typeClass,
                                map
                                    .invoke("get", DEFAULT_GETTER_VALUE)
                                    .cast(Map::class.java)
                                    .invoke("size")
                            ).invoke("typeReturn", map)
                            .cast(jClass)
                    } else {
                        companion
                            .invoke("yamlParser", typeClass)
                            .invoke("typeReturn", map)
                            .cast(jClass)
                    }
                }
                else {
                    companion
                        .invoke("yamlParser", jClass, map.invoke("size"))
                        .invoke("newInstance", map)
                        .cast(jClass)
                }
            }
        }
    }

    private fun typeParser(method: MethodMaker, v: Variable, type: Class<*>, func: String): Variable =
        method
            .`var`(type)
            .invoke(func, v.cast(String::class.java))
}
